///////////////////////////////////////////////////////////////////////////////
//
//  Copyright PHOENIX CONTACT Electronics GmbH
//
///////////////////////////////////////////////////////////////////////////////
#pragma once
#include "Arp/System/Core/Arp.h"
#include "Arp/System/Rsc/Services/IRscService.hpp"
#include "MqttClientServiceProxyFactory.hpp"
#include "Arp/System/Rsc/Services/RscString.hxx"
#include "Arp/System/Rsc/Services/RscVariant.hxx"
#include "ConnectOptions.hpp"
#include "Message.hpp"

// DO NOT MODIFY THIS FILE, THIS FILE IS AUTOGENERATED BY IMqttClientService.cs

namespace PxceTcs { namespace MqttClient { namespace Services
{

using namespace Arp;
using namespace Arp::System::Rsc::Services;

/// <summary>
/// MQTT Client service
/// </summary>
class IMqttClientService : public IRscService
{
public: // typedefs
    typedef std::shared_ptr<IMqttClientService>   Ptr;

public: // construction/destruction
    /// <summary>Constructs an <see cref="IMqttClientService" /> instance.</summary>
    IMqttClientService(void);
    /// <summary>Destructs this instance and frees all resouces.</summary>
    virtual ~IMqttClientService(void);

public: // static policy operation
    static IRscServiceProxyFactory& GetProxyFactory(void);

public: // abstract operations
    /// <summary>
    /// Connects to an MQTT server using the specified options.
    /// </summary>
    /// <param name="clientId">the client identifier.</param>
    /// <param name="opts">the connection options.</param>
    /// <returns>0: success</returns>
    virtual int32   Connect(int32 clientId, const ConnectOptions& opts) = 0;

    /// <summary>
    /// Create a client that can be used to communicate with an MQTT server.
    /// </summary>
    /// <param name="serverURI">the address of the server to connect to, specified as a URI.</param>
    /// <param name="clientId">a client identifier that is unique on the server being connected to.</param>
    /// <returns>a positive value representing the unique client identifier, or a negative number for failure.</returns>
    virtual int32   CreateClient(const RscString<512>& serverURI, const RscString<512>& clientId) = 0;

    /// <summary>
    /// Destroy the client.
    /// </summary>
    /// <param name="clientId">the client identifier.</param>
    /// <returns>0: success</returns>
    virtual int32   DestroyClient(int32 clientId) = 0;

    /// <summary>
    /// Disconnects from the server.
    /// </summary>
    /// <param name="clientId">the client identifier.</param>
    /// <param name="timeoutMS">the amount of time in milliseconds to allow for existing work to finish before disconnecting.
    /// A value of zero or less means the client will not quiesce.</param>
    /// <returns>0: success</returns>
    virtual int32   Disconnect(int32 clientId, int32 timeoutMS) = 0;

    /// <summary>
    /// Return the maximum time to wait for an action to complete.
    /// </summary>
    /// <param name="clientId">the client identifier.</param>
    /// <returns>the timeout in milliseconds.</returns>
    virtual int32   GetTimeout(int32 clientId) = 0;

    /// <summary>
    /// Determines if this client is currently connected to the server.
    /// </summary>
    /// <param name="clientId">the client identifier.</param>
    /// <returns>\em true if the client is currently connected, \em false if not.</returns>
    virtual boolean IsConnected(int32 clientId) = 0;

    /// <summary>
    /// Publishes a message to a topic on the server.
    /// </summary>
    /// <param name="clientId">the client identifier.</param>
    /// <param name="topic">the topic to publish.</param>
    /// <param name="payload">the data to publish.</param>
    /// <param name="length">the size in bytes of the data.</param>
    /// <param name="qos">the QoS for message delivery.</param>
    /// <param name="retained">whether the broker should retain the message.</param>
    /// <returns>0: success</returns>
    virtual int32   Publish(int32 clientId, const RscString<512>& topic, RscVariant<512> payload, uint32 length, int32 qos, boolean retained) = 0;

    /// <summary>
    /// Reconnects the client using options from the previous connect.
    /// </summary>
    /// <param name="clientId">the client identifier.</param>
    /// <returns>0: success</returns>
    virtual int32   Reconnect(int32 clientId) = 0;

    /// <summary>
    /// Set the maximum time to wait for an action to complete.
    /// </summary>
    /// <param name="clientId">the client identifier.</param>
    /// <param name="timeoutMS">the timeout in milliseconds.</param>
    /// <returns>0: success</returns>
    virtual int32   SetTimeout(int32 clientId, int32 timeoutMS) = 0;

    /// <summary>
    /// Subscribe to a topic, which may include wildcards, using a QoS of 1.
    /// </summary>
    /// <param name="clientId">the client identifier.</param>
    /// <param name="topicFilter">a single topic to subscribe.</param>
    /// <returns>0: success</returns>
    virtual int32   Subscribe(int32 clientId, const RscString<512>& topicFilter) = 0;

    /// <summary>
    /// Try to read the next message from the queue without blocking.
    /// The complete message payload is returned as a separate parameter.
    /// </summary>
    /// <param name="clientId">the client identifier.</param>
    /// <param name="msg">the next message in the queue.</param>
    /// <returns>0: no new message, 1: new message</returns>
    virtual int32   TryConsumeMessage(int32 clientId, Message& msg) = 0;

    /// <summary>
    /// Requests the server unsubscribe the client from a topic.
    /// </summary>
    /// <param name="clientId">the client identifier.</param>
    /// <param name="topicFilter">a single topic to unsubscribe.</param>
    /// <returns>0: success</returns>
    virtual int32   Unsubscribe(int32 clientId, const RscString<512>& topicFilter) = 0;

private: // deleted methods (for non-copyable classes)
    IMqttClientService(const IMqttClientService& arg) = delete;
    IMqttClientService& operator=(const IMqttClientService& arg) = delete;
};

///////////////////////////////////////////////////////////////////////////////
// inline methods of class IMqttClientService
inline IMqttClientService::IMqttClientService(void)
{
}

inline IMqttClientService::~IMqttClientService(void)
{
}

inline IRscServiceProxyFactory& IMqttClientService::GetProxyFactory()
{
    return MqttClientServiceProxyFactory::GetInstance(); 
}

}}} // end of namespace PxceTcs::MqttClient::Services
